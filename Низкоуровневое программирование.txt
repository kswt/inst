Низкоуровневое программирование (ASM)

Васильев Николай Петрович

Литература:
Юров Ассемблер. Учебник для вузов. Том 1. !!Обязательно
Абель. Программирование на языке Ассемблера
Финогенов. Справочник по системным функциям MS-DOS 
Ассемблер Linux для программистов C

Задачи:
	вводная
1. арифметика
2. логические операции (сдвиги)
3. обработка двумерных массивов (матриц)
4. обработка строк (работа с памятью, работа с консолью, работа с файлами, разбивка задачи на несколько модулей)
5. * переписать задачу 4Б под linux/mac

Схемы:
1. Комбинационная (o(t) = f(i(t))
2. Последовательностные (схемы с памятью) I(ti),s(ti) => o(ti+1), s(t1+1)


s(t0) => известен

Для любого ti
o(ti) = f(i(ti),s(ti-1))
s(ti) = g(i(ti),s(ti-1))

Инструкции ассемблера соответствуют машинным командам, а также содержат мнемонические обозначения, понятные человеку.


Машинное слово — величина данных в битах, которая может быть обработана одной командой или инструкцией. 

Регистры IA32: 
1. РОН: (E)AX(h,l), EBX, ECX, EDX 
2. Индексные: (E)SI (source index), EDI(destination index)
3. Регистры-указатели: EIP(instruction), ESP(stack), EBP(base) — дополнительный указатель стека при прямом доступе к нему.
4. Сегментные регистры: CS(code segment), SS(stack segment), DS(data segment), ES(extended), FS, GS. Они используются для хранения начального адреса некоторой области оперативной памяти, называемой сегментом.


# 15.02.07. Лекция 2

Флаговый регистр (E)FLAGS — слово состояния процессора (программы)

## Формат команд

1. Безадресные 		cbw (convert byte to word). Таких команд не очень много
2. Одноадресные 	inc ax
3. Двухадресные		mov dst, src (большинство). Не допускаются следующие комбинации: к,р; к,п; п,п
4. Трехадресные		(мало)

Имеются 3 режима работы процессора:
1. Реальный (режим реального адреса) — при включении питания. Разрядность адреса 20 бит. Он состоит из двух частей: сегмент (регистр DS) и смещение (16 разрядов)

Physical address = DS*16+offset

В современных ОС адрес сегмента = 0. 

2. Защищенный режим (protected mode) 32, 36 или 64 бита.
3. Режим виртуального процессора (VM). — комбинация процессов, работающих в предыдущих режимах.

## Режимы адресации

1. Неявная — местоположение данных определяется самой командой.
2. Непосредственная — данные определены внутри самой команды.
3. Прямая — местоположение данных указано в команде
4. Косвенная — в команде находится место местоположения данных

mov ax, 5
mov bx,ax
mov ax,100
mov [bx],ax

## Команды пересылки

mov dst,src
xchg dst,src ;exchange

Они не влияют на флаги

## Команды сложения

add dst, src ;dst = dst+src
adc dst, src ;dst = dst+src+cf
inc dst
Сложение, как и все арифметические команды, влияет на флаги

## Команды вычитания

dec dst
sub dst,src
sbb dst,src

## Умножение

mul src; для беззнаковых чисел
imul src
Результат, а также первый операнд заданы неявно.

### Логика работы операции умножения
src (байты)	1-й множитель	результат
1		AL		AX
2		AX		DX:AX
4		EAX		EDX:EAX ; Обязательно вставить .486

Все величины в вычислительных системах хранятся:
1. В двоичной системе счисления.
2. В дополнительном коде.
Данные хранятся по принципу: младшие данные по младшему адресу(little endian)
mov bx, 55
mov [bx], ax

Сложение и вычитание не зависит от знака.

## Операция деления
div src
idiv src

src(байты)	Делимое		Частное		Остаток
1		2(dw) AX	1(db) AL	1(db) AH
2		4(dd) DX AX	2 AX		2 DX
4		8(dq) EDX EAX	4 EAX		4 EDX

Операнд умножения и деления не может быть константой (так как неизвестен размер)

## Команды конверсии

cbw 	AL -> AX 
cwd 	AX -> DX AX
cwde	AX -> EAX
cdq	EAX -> EDX EAX

(a^7)/d  d - число; с - остаток = dq

.model small;1 data 1 code

.data
a db 10
b db 120
c dd ?
d dd ?

.code
.486

mov ax,@data
mov ds,ax

mov al, a
imul al; ax =a^2
mov bx, ax

imul ax; dx:ax = a^4
mov cs,dx

shl ecx, 16

mov cx, ax

mov ax, bx

cwde ;eax = a^2

imul ecx


mov ebx, eax

mov al,a
cbw
cwde

imul ebx

mov ebx,eax
mov al,b
cbw
cwde
xchg ebx,eax

idiv ebx

mov c,eax
mov d,edx

mov ah, 4Ch
int 21h

end
Деление на 0 возникает тогда, когда не хватает места для сохранения результата


## Команды сдвига

shl dst, 1|cl|const

Последний сдвинутый бит попадает в CF — carry flag

sal - если произошло изменение знака, то устанавливается флаг OF


Циклический сдвиг
rol — rotate left, последний сдвинутый разряд попадает в CF
rcl — rotate CF left  - сдвиг происходит через CF

#DosBOX

в конец файла настроек записать:
mount c c:\tasm
c:\


 


mov ax,@data
mov ds,ax



# 01.02.2017
# Флаги
На флаги не окаывают влияние команды пересылки, перехода, и те команды, которые не выполняют вычисления.

FLAGS, EFLAGS

CF — флаг переноса и заёма

ZF — устанавливается, если был получен нулевой результат

SF — флаг знака

OF — переполнение. Устанавливается, если знак результата не совпадает с ожидаемым.

DF (direction flag) — определяет направление обработки строк. 1 — справа налево.

IF — флаг прерываний. 1 — прерывания разрешены, 0 — запрещены

TF (trap flag) — позволяет выполнять программу пошагово

Флагами можно управлять принудительно. Для этого используется 3 группы команд: CLx (clear) , STx (set) , CMx (comma) — инверсия

cmp a, 5 ;выполним вычитание без записи результата
jl m1
mov b,2
jmp m2
m1: mov b,1
m2: 


## Команды перехода

jmp m ; Метка - смещение в сегменте кода

### Команды условного перехода:
Переход по значению флага:
Jx m
JNx m



Команды условного перехода имеют синонимы: 
jz = je
jnz = jne

Команды по сравнению величин со знаком:

cmp a, b
	Вар.1	Вар.2
a<b	jl	jnge		
a>b	jg	jnle
a<=b	jle	jng
b=>b	jge	jnl
a=b	je	jz
a≠b	jne	jnz

Команды по сравнению величин без знака

cmp a, b
	Вар.1	Вар.2
a<b	jb	jnae		
a>b	ja	jnbe
a<=b	jbe	jna
b=>b	jae	jnb
a=b	je	jz
a≠b	jne	jnz

Условный переход возможен максимум на 128 байт назад и максимум на 127 вперед (короткий переход)

## Циклы

mov cx, n; число итераций
m:

loop m 

Команда loop вычитает из регистра CX единицу. Если результат ≠ 0, то идёт переход (короткий) на указанную метку.
Иначе переход на следующую команду.

Последняя итерация имеет номер 1

Пример: дано слово, необходимо посчитать количество единиц.

.model small
.data
	slovo 	dw 	5555h
	ed	db	0
	
.code
.486

mov ax, @data
mov ds, ax
mov ax, slovo
mov cx, 16
m:
	shl ax, 1
	jnc m1
	inc ed
m1: loop m

mov ah, 4Ch
int 21h
end

## Логические команды

not dst

and dst, src
or
nand
nor
xor

test d, s; аналог and, но результат не сохраняется

## Работа со стеком

.model small
.stack 100h ; extent в байтах


Запись в стек:
push src

Чтение из стека:
pop dst

Ограничения: размерность src = 16 бит (слово)

Если указано .386, то в команде push можно указать константу, размером не больше 0FFFF
При записи в стек указатель стека SP уменьшается на 2. При чтении из стека указатель увеличивается на 2. 
Перед выходом из программы указатель стека должен быть равен изначальному значению.


# 15.03.2017

## Массивы

lea <регистр> <имя массива> - поместить адрес начала массива в регистр
mas[si] - адресация с использованием индексного регистра
mas[bx]
ds:mas[bp] 

### Объявление массива
.data
	mas dw 1,2,3,4,5

	mas dw  30 dup(?)

Пример: сумма элементов массива

.data
	mas dw 100 dup(?)
	n dw 100
.code
	mov ax, @data
	mov ds, ax

	xor ax, ax
	mov cx, n
	xor si, si
label:	add ax, mas[si]
	add si, 2
	loop label

Инвертировать массив:
Вариант 1:

mov di, n;di = n
dec di; di = n-1

sal di,1

xor si,si
mov cx, n
sar cx, 1;cx = n/2
label: xchg ax, max[si]
xchg mas[di],ax
xchg mas[si],ax
add si, 2
sub di, 2
loop label


Вариант 2:

mov cx, n
xor si, si
l1:
push mas, si
add si, 2
loop l1
mov cx, n
xor si, si
l2:
pop mas, si
add si, 2
loop l2

### Матрицы

matr[bx][si]

n строк
m столбцов
r разрядность

смещение j-го столбца: (j-1)*r
смещение i-й строки: i*m*r

Пример: поменять местами первый и последний столбец:

m dw 10; столбцы
n dw 10; строки

matr dw 100 dup(?)

mov ax, m
sal ax, 1; ax = 2m

mov bp, m
dec bp

sal bp, 1; bp = 2

xor bx, bx
xor si, si

mov cx, n
label:
xchg dx, matr[bx][si]
xchg dx, ds:matr[bp][si]
xchg dx, matr[bx][si]
add si, ax
loop label


# 22.03.17

## Режимы адресации процессора архитектуры IA32 в реальном режиме

1. Неявная (implied) (операнды подразумеваются в самой команде)
2. Непосредственная (immediate) (операнд задан в самой команде (константа))
3. Прямая (direct) (в команде присутствует местоположение операнда)
4. Косвенная (indirect)

Признаком косвеной адресации являются квадратные скобки. В случае косвенной адресации при работе с константой нужно указывать размер операнда: mov (byte|word|dword|qword) ptr [bx] 5

### Прямая регистровая адресация

mov al, 5; Операнд хранится в регистре

### Прямая адресация к памяти

a db 5

mov a, al

Указывается адрес ячейки памяти, где хранится операнд

Пример:
.data
	a db 5; 0 смещение (displacement/effective address)
	b dw 7; 1
.code
	
### Косвенная регистровая адресация

Смещение одного из операндов находится в определенном регистре.
Два способа записи смещения в регистр:
1.	lea bx, a
2.	mov bx, offset a; более быстрый
;Компилятор подставит константу, соответствующую смещению данных
	mov [bx], al

При регистровой косвенной адресации в реальном режиме можно использовать только следующие регистры:
bx, bp, si, di

### Косвенная регистровая относительная адресация

Эффективный адрес определяется как сумма содержимого регистра и константы.

mov [bx+1], al

В косвенной адресации не проверятеся размер пересылаемых данных

### Базовая индексная адресация
Эффективный адрес образуется как сумма состояния двух регистров, базового(bx, bp) и индексного (si, di)
mov [bx][si], al
mov [bx+si], al

### Базовая индексная со смещением
mov a[bx][si], al
mov [bx+si+offset a], al

## Матрицы

Строки si
Столбцы bx

.stack 100h
.data
	m equ 4; константы поддерживают сложение, вычитание и умножение
	n equ 4
	a db

a db 1,2,3,4
 db 5,6,7,8
 db 9,10,11,12
 db 12,14,15,16

b db m*n dup(0)

При переходе от внешнего цикла к внутреннему следует записывать счетчик цикла в стеке, при переходе от внутреннего к внешнему - восстановление


## Строки (с цепочками символов)

a db "Stroka"
len equ $-a;сразу же за строкой
        тек.адрес-смещение
### Команды (примитивы) обработки строк
Все команды безадресные.

movs(b|w|d|q)
lods(b|w|d|q);очередной символ источника записывается в ax, после чего si увеличивается.
stos(b|w|d|q);записывает аккумулятор в строку-приемник, после чего di увеличивается
cmps;посимвольное сравнение строк. Выполняет команду вычитания между очередными символами исходной и результурующей строкой.
scas(b|w|d|q);сканирование строк: сравнение аккумулятора с очередным символом строки-приемника
Префиксы:
repz(repe);команда выполняется до тех пор, пока cx>0 и zf =1
repnz(repne)




Строка-источник адресуется с помощью ds:si


Строка-приемник - es:di

Направление обработки строк определяется флагом df
0 - слева направо, от младших адресов к старшим
1 - 

cld; df=0
std; df=1

Пример: копирование из одной строки в другую

.data
	a db 'hello'
	len equ $-a
	b db len dup(?)
.code
	mov ax, @data
	mov ds, ax
	mov es, ax
;	xor si, si
;	xor di, di
	lea si, a
	lea di, b
	cld
	mov cx, len
	rep movsb;копирование очередного символа из источника в приемник и увеличение si, di на 1
	;выполнять команду CX раз
	
	mov ah 4ch
	int 21h
end


Пример: дана строка. Заменить все пробелы на звездочки.

.data
	a db "hello, my world!"
	len equ $-a
	b db len dup(?)
.code
	mov ax, @data
	mov ds, ax
	mov es, ax
	cld
	lea si,a
	lea di,b
	mov cx, len

m1:
	lodsb
	cmp al, ' '
	jnz m2
	mov al, '*'
m2:
	stosb
	loop m1	

	mov ah, 4ch
	int 21h
end

## Подпрограммы

Часть кода, описываемая однократно, и вызываемая произвольное число раз.При работе с процедурами команда вызова сохраняет точку возврата в стеке.
Наличие стека в программе обязательно для работы с процедурами.
call <name>

proc1 proc (near|far)


ret
endp

команда call запоминает в стеке адрес следующей команды и выполняет переход на указанную метку. Команда ret считывает из стека адрес возврата и выполняет на него переход


# 29.03.2017

Передача параметров в процедуру выполняется одним из трех способов:
1. Общая память (глобальные переменные). Недостаток: привязка процедуры к одной программе
2. Регистры. Недостаток: небольшое число регистров
3. Стек. Основной способ передачи операндов.

Указатель стека всегда указывает на последнее добавленное значение
Для извлечения аргументов из стека используется регистр BP (дополнительный указатель стека)
.data
	a dw 7
.code
	push a
	call proc1
	
	
proc1 proc near;Ближний адрес, достаточно только смещения
	push ax; Запоминаем содержимое AX в стеке
	push bp;
	mov bp, sp
	
	mov ax, [bp+6]
	...
	
	pop bp
	pop ax
	ret 2
proc1 endp

При работе с параметрами команды ret в чистом виде недостаточно.
Нужна команда ret 2. Команда ret с аргументом добавляет указанное значение к указателю стека.

## Передача по ссылке

	mov bx, [bp+6]
	push offset a
	mov word ptr[bx],1

При передаче по ссылке можно сразу воздействовать на первоисточник данных.

pusha	;Записать в стек ax, cx, dx, bx, si, di, bp, sp
	;sp уменьшается на 16



